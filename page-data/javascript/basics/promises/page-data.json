{
    "componentChunkName": "component---src-pages-mdx-fields-category-mdx-fields-sub-category-mdx-fields-short-slug-js",
    "path": "/javascript/basics/promises/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Promises","date":"January 11, 2022","description":"All you need to know about promises"},"fields":{"subCategory":"basics"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Promises\",\n  \"date\": \"2022-01-11\",\n  \"description\": \"All you need to know about promises\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Promises\"), mdx(VersionTag, {\n    version: \"es6\",\n    mdxType: \"VersionTag\"\n  }), mdx(\"p\", null, \"Promises are fundamental for working with asynchronous code. Promise is an object representing eventual completion or failure of operation (and its returned value).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Notice:\"), \" this method of dealing with asynchronous code was created because using a lot of callbacks makes code very messy.\"), mdx(\"h2\", null, \"Example of a \", mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Callback Hell\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"fs.readdir(source, function (err, files) {\\n  if (err) {\\n    console.log(\\\"Error finding files: \\\" + err);\\n  } else {\\n    files.forEach(function (filename, fileIndex) {\\n      console.log(filename);\\n      gm(source + filename).size(function (err, values) {\\n        if (err) {\\n          console.log(\\\"Error identifying file size: \\\" + err);\\n        } else {\\n          console.log(filename + \\\" : \\\" + values);\\n          aspect = values.width / values.height;\\n          widths.forEach(\\n            function (width, widthIndex) {\\n              height = Math.round(width / aspect);\\n              console.log(\\n                \\\"resizing \\\" + filename + \\\"to \\\" + height + \\\"x\\\" + height\\n              );\\n              this.resize(width, height).write(\\n                dest + \\\"w\\\" + width + \\\"_\\\" + filename,\\n                function (err) {\\n                  if (err) console.log(\\\"Error writing file: \\\" + err);\\n                }\\n              );\\n            }.bind(this)\\n          );\\n        }\\n      });\\n    });\\n  }\\n});\\n\")), mdx(\"p\", null, \"Thanks to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://callbackhell.com/\"\n  }, \"Callback Hell\"), \".\"), mdx(\"h2\", null, \"Example with Promises\"), mdx(\"p\", null, \"Some rules:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Name promise based functions using verbs (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getJSON\"), \" etc.)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Promise represents single operation (every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then\"), \" fires only once)\"))), mdx(\"h3\", null, \"Example with \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"setTimeout\")), mdx(LiveExample, {\n    link: \"https://jsfiddle.net/fedek6/z0gnf75h/\",\n    mdxType: \"LiveExample\"\n  }), mdx(\"p\", null, \"This is no-nonsense example on how promises work:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const wait = (duration) => {\\n  return new Promise((resolve, reject) => {\\n    if (duration < 0) {\\n      reject(new Error(\\\"Duration cannot be negative\\\"));\\n    }\\n\\n    setTimeout(() => {\\n      resolve(duration);\\n    }, duration);\\n  });\\n};\\n\\nconst handleChain = (lastDuration, newDuration) => {\\n  console.log(`Another ${lastDuration / 1000}s has passed`);\\n\\n  if (newDuration) {\\n    return wait(newDuration);\\n  }\\n};\\n\\n// OK run\\nwait(1000)\\n  .then((d) => console.log(`${d / 1000}s has passed`))\\n  .catch((e) => console.log(e.message));\\n\\n// Error run\\nwait(-1000)\\n  .then(() => console.log(\\\"One second has passed\\\"))\\n  .catch((e) => console.log(\\\"Error\\\", e.message));\\n\\n// Simple chain\\nwait(1000)\\n  .then((d) => handleChain(d, 2000))\\n  .then((d) => handleChain(d, 3000))\\n  .then((d) => handleChain(d))\\n  .catch((e) => console.log(e.message));\\n\")), mdx(\"h2\", null, \"Using fetch\"), mdx(LiveExample, {\n    link: \"https://jsfiddle.net/fedek6/g6vq97s2/\",\n    mdxType: \"LiveExample\"\n  }), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" is a global method that provides easy way to fetch remote resources. It's promise based and replaces old \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XMLHttpRequest\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// OK run\\nfetchWithTimeout(\\\"https://catfact.ninja/fact\\\", { timeout: 1000 })\\n  .then((response) => response.json())\\n  .then((data) => {\\n    const { fact } = data;\\n    console.log(\\\"Cat fact:\\\", fact);\\n  })\\n  .catch((error) => {\\n    console.log(\\\"Error:\\\", error.message);\\n  });\\n\\n// Error run\\nfetchWithTimeout(\\\"https://catfact.ninja/fakt\\\", { timeout: 1000 })\\n  .then((response) => response.json())\\n  .then((data) => {\\n    const { fact } = data;\\n    console.log(\\\"Cat fact:\\\", fact);\\n  })\\n  .catch((error) => {\\n    console.log(\\\"Error:\\\", error.message);\\n  });\\n\\n/**\\n * We need fetch with timeout,\\n * because standard 90 - 300 is way to much!\\n * @link https://dmitripavlutin.com/timeout-fetch-request/\\n */\\nasync function fetchWithTimeout(resource, options = {}) {\\n  const { timeout = 8000 } = options;\\n\\n  const controller = new AbortController();\\n  const id = setTimeout(() => controller.abort(), timeout);\\n  const response = await fetch(resource, {\\n    ...options,\\n    signal: controller.signal,\\n  });\\n  clearTimeout(id);\\n  return response;\\n}\\n\")), mdx(\"h2\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"await\")), mdx(VersionTag, {\n    version: \"es2017\",\n    mdxType: \"VersionTag\"\n  }), mdx(LiveExample, {\n    link: \"https://jsfiddle.net/fedek6/x0745rsy/\",\n    mdxType: \"LiveExample\"\n  }), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" constitute a wrapper for promise based code. In the main thread you still need to treat this functions with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catch\"), \" (because they return promise).\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Important:\"), \" You can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" only in other \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" function (or in Node's top level await).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const wait = (duration) => {\\n  return new Promise((resolve, reject) => {\\n    if (duration < 0) {\\n      reject(new Error(\\\"Duration cannot be negative\\\"));\\n    }\\n\\n    setTimeout(() => {\\n      resolve(duration)\\n    }, duration);\\n  });\\n}\\n\\nconst handleChain = (lastDuration, newDuration) => {\\n  console.log(`Another ${lastDuration / 1000}s has passed`);\\n\\n  if (newDuration) {\\n    return wait(newDuration);\\n  }\\n}\\n\\n// Version without execption\\nconst asyncAwaitWrap = async () => {\\n    let totalTime = 0;\\n\\n    const duration1 = await wait(1000);\\n    totalTime += duration1;\\n    handleChain(duration1);\\n    const duration2 = await wait(2000);\\n    totalTime += duration2;\\n    handleChain(duration2);\\n    const duration3 = await wait(1000);\\n    totalTime += duration3;\\n    handleChain(duration3);\\n\\n    return totalTime;\\n}\\n\\n// Version that brakes\\nconst asyncAwaitWrapBad = async () => {\\n    const duration1 = await wait(1000);\\n    handleChain(duration1);\\n    const duration2 = await wait(-2000);\\n    handleChain(duration2);\\n    const duration3 = await wait(1000);\\n    handleChain(duration3);\\n\\n    return true;\\n}\\n\\nasyncAwaitWrap()\\n    .then(r => {\\n        console.log(\\\"Total time in asyncAwaitWrap\\\", `${r / 1000}s`);\\n\\n        return asyncAwaitWrapBad();\\n    })\\n    .then(r => {\\n        console.log(\\\"Result of asyncAwaitWrapBad\\\", r);\\n    })\\n    .catch(e => console.log(\\\"Error\\\", e.message));\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"allMdx":{"group":[{"fieldValue":"advanced","edges":[{"node":{"frontmatter":{"title":"Filtering"},"fields":{"shortSlug":"filtering","subCategory":"advanced"},"slug":"javascript/advanced/filtering/"}},{"node":{"frontmatter":{"title":"Flattening objects"},"fields":{"shortSlug":"flattening-objects","subCategory":"advanced"},"slug":"javascript/advanced/flattening-objects/"}},{"node":{"frontmatter":{"title":"Asynchronous chunking"},"fields":{"shortSlug":"asynchronous-chunking","subCategory":"advanced"},"slug":"javascript/advanced/asynchronous-chunking/"}}],"totalCount":3},{"fieldValue":"basics","edges":[{"node":{"frontmatter":{"title":"Double NOT (!!)"},"fields":{"shortSlug":"double-not-operator","subCategory":"basics"},"slug":"javascript/basics/double-not-operator/"}},{"node":{"frontmatter":{"title":"For loops"},"fields":{"shortSlug":"for-loops","subCategory":"basics"},"slug":"javascript/basics/for-loops/"}},{"node":{"frontmatter":{"title":"Strings"},"fields":{"shortSlug":"strings","subCategory":"basics"},"slug":"javascript/basics/strings/"}},{"node":{"frontmatter":{"title":"Promises"},"fields":{"shortSlug":"promises","subCategory":"basics"},"slug":"javascript/basics/promises/"}},{"node":{"frontmatter":{"title":"instanceof operator"},"fields":{"shortSlug":"instanceof-operator","subCategory":"basics"},"slug":"javascript/basics/instanceof-operator/"}},{"node":{"frontmatter":{"title":"in operator"},"fields":{"shortSlug":"in-operator","subCategory":"basics"},"slug":"javascript/basics/in-operator/"}},{"node":{"frontmatter":{"title":"Nullish Coalescing Operator"},"fields":{"shortSlug":"nullish-coalescing-operator","subCategory":"basics"},"slug":"javascript/basics/nullish-coalescing-operator/"}},{"node":{"frontmatter":{"title":"Optional chaining"},"fields":{"shortSlug":"optional-chaining","subCategory":"basics"},"slug":"javascript/basics/optional-chaining/"}},{"node":{"frontmatter":{"title":"Destructuring assignment"},"fields":{"shortSlug":"destructuring","subCategory":"basics"},"slug":"javascript/basics/destructuring/"}},{"node":{"frontmatter":{"title":"Symbols"},"fields":{"shortSlug":"symbols","subCategory":"basics"},"slug":"javascript/basics/symbols/"}}],"totalCount":10},{"fieldValue":"debug","edges":[{"node":{"frontmatter":{"title":"console.log usage"},"fields":{"shortSlug":"console-log","subCategory":"debug"},"slug":"javascript/debug/console-log/"}}],"totalCount":1},{"fieldValue":"dom","edges":[{"node":{"frontmatter":{"title":"querySelector"},"fields":{"shortSlug":"query-selector","subCategory":"dom"},"slug":"javascript/dom/query-selector/"}}],"totalCount":1},{"fieldValue":"events","edges":[{"node":{"frontmatter":{"title":"Long mouse event"},"fields":{"shortSlug":"long-mouse-event","subCategory":"events"},"slug":"javascript/events/long-mouse-event/"}},{"node":{"frontmatter":{"title":"Event delegation"},"fields":{"shortSlug":"event-delegation","subCategory":"events"},"slug":"javascript/events/event-delegation/"}}],"totalCount":2},{"fieldValue":"math","edges":[{"node":{"frontmatter":{"title":"Random number in the range"},"fields":{"shortSlug":"random-number","subCategory":"math"},"slug":"javascript/math/random-number/"}}],"totalCount":1}]}},"pageContext":{"id":"f4687fbf-c312-52c2-826e-188c8b2203e7","fields__category":"javascript","fields__subCategory":"basics","fields__shortSlug":"promises","__params":{"fields__category":"javascript","fields__subCategory":"basics","fields__shortSlug":"promises"}}},
    "staticQueryHashes": ["2420640694"]}