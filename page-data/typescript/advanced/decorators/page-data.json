{
    "componentChunkName": "component---src-pages-mdx-fields-category-mdx-fields-sub-category-mdx-fields-short-slug-js",
    "path": "/typescript/advanced/decorators/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Decorators","date":"February 9, 2021","description":"Concept of Decorators"},"fields":{"subCategory":"advanced"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Decorators\",\n  \"date\": \"2021-02-09\",\n  \"description\": \"Concept of Decorators\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Concept of Decorators\"), mdx(\"p\", null, \"Decorators are popular in Angular framework. They are also proposed as future standard for JavaScript.\"), mdx(\"p\", null, \"To enable Decorators add the following option to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsconfig\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"experimentalDecorators\\\": true\\n  }\\n}\\n\")), mdx(\"h2\", null, \"Most basic (stupid) example you'll find\"), mdx(\"p\", null, \"This Decorator's only role is to replace required property of object to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cholibka\"), \"\\u2728\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/**\\n * This is Decorator definition.\\n */\\nconst cholibka =\\n  (propName: string) =>\\n  (\\n    constructor: any,\\n    methodName: string,\\n    descriptor: PropertyDescriptor\\n  ): any => {\\n    const origFunction = descriptor.value;\\n    descriptor.value = function wrapper() {\\n      let result = origFunction.apply(this);\\n\\n      // Here the magic happens\\n      return { ...result, [propName]: \\\"cholibka!\\\" };\\n    };\\n  };\\n\\n/**\\n * Method of this class uses `cholibka` Decorator.\\n */\\nclass Test {\\n  @cholibka(\\\"foo\\\")\\n  static test() {\\n    return {\\n      test: \\\"Hello World!\\\",\\n      foo: \\\"bar\\\",\\n    };\\n  }\\n}\\n\\n// Modified output\\nconsole.log(Test.test()); // { \\\"test\\\": \\\"Hello World!\\\", \\\"foo\\\": \\\"cholibka!\\\" }\\n\")), mdx(\"p\", null, \"In short, you can add a wrapper to a method and modify its returned value.\"), mdx(\"h2\", null, \"Using metadata\"), mdx(\"p\", null, \"Firstly you'll need to install an additional package:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"npm install reflect-metadata\\n\")), mdx(\"p\", null, \"Secondly you'll need to modify your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tsconfig\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"compilerOptions\\\": {\\n    \\\"experimentalDecorators\\\": true,\\n    \\\"emitDecoratorMetadata\\\": true\\n  }\\n}\\n\")), mdx(\"p\", null, \"And then write a decorator in the following way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import \\\"reflect-metadata\\\";\\n\\nexport const addClass =\\n  (...classNames: string[]) =>\\n  (\\n    constructor: any,\\n    methodName: string,\\n    descriptor: PropertyDescriptor\\n  ): any => {\\n    if (\\n      Reflect.getMetadata(\\\"design:returntype\\\", constructor, methodName) ===\\n      HTMLElement\\n    ) {\\n      const origFunction = descriptor.value;\\n\\n      // Debug info\\n      console.log(\\n        \\\"design:returntype\\\",\\n        Reflect.getMetadata(\\\"design:returntype\\\", constructor, methodName).name\\n      ); // design:returntype HTMLElement\\n\\n      const paramTypes = Reflect.getMetadata(\\n        \\\"design:paramtypes\\\",\\n        constructor,\\n        methodName\\n      ).map((c: any) => c.name);\\n\\n      console.log(\\\"design:paramtypes\\\", paramTypes.join(\\\", \\\")); // design:paramtypes String\\n\\n      console.log(\\n        \\\"design:type\\\",\\n        Reflect.getMetadata(\\\"design:type\\\", constructor, methodName).name\\n      ); // design:type Function\\n\\n      descriptor.value = function wrapper(...args: any) {\\n        const content: HTMLElement = origFunction.apply(this, args);\\n        classNames.forEach((c) => content.classList.add(c));\\n        return content;\\n      };\\n    }\\n  };\\n\")), mdx(\"p\", null, \"Usage example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { addClass } from \\\"./addClass\\\";\\ntype AllHtmlTags = keyof HTMLElementTagNameMap;\\n\\nclass Component {\\n  constructor(private content: string) {}\\n\\n  // This will decorate returned HTMLElement with CSS classes.\\n  @addClass(\\\"some-class\\\", \\\"other-class\\\")\\n  getComponent(type: AllHtmlTags): HTMLElement {\\n    const element: HTMLElement = document.createElement(type);\\n    element.textContent = this.content;\\n    return element;\\n  }\\n}\\n\\nconst c = new Component(\\\"CHOLIBKA!\\\");\\n\\ndocument.body.appendChild(c.getComponent(\\\"h1\\\"));\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"allMdx":{"group":[{"fieldValue":"advanced","edges":[{"node":{"frontmatter":{"title":"Decorators"},"fields":{"shortSlug":"decorators","subCategory":"advanced"},"slug":"typescript/advanced/decorators/"}}],"totalCount":1},{"fieldValue":"basics","edges":[{"node":{"frontmatter":{"title":"Assertions"},"fields":{"shortSlug":"assertions","subCategory":"basics"},"slug":"typescript/basics/assertions/"}},{"node":{"frontmatter":{"title":"The basics of types"},"fields":{"shortSlug":"types","subCategory":"basics"},"slug":"typescript/basics/types/"}},{"node":{"frontmatter":{"title":"Basic classes"},"fields":{"shortSlug":"classes","subCategory":"basics"},"slug":"typescript/basics/classes/"}},{"node":{"frontmatter":{"title":"Maps"},"fields":{"shortSlug":"maps","subCategory":"basics"},"slug":"typescript/basics/maps/"}}],"totalCount":4},{"fieldValue":"data-types","edges":[{"node":{"frontmatter":{"title":"Enums"},"fields":{"shortSlug":"enums","subCategory":"data-types"},"slug":"typescript/data-types/enums/"}},{"node":{"frontmatter":{"title":"Arrays"},"fields":{"shortSlug":"arrays","subCategory":"data-types"},"slug":"typescript/data-types/arrays/"}}],"totalCount":2}]}},"pageContext":{"id":"89be38e8-8caa-5ec0-bfe8-b5253461fab2","fields__category":"typescript","fields__subCategory":"advanced","fields__shortSlug":"decorators","__params":{"fields__category":"typescript","fields__subCategory":"advanced","fields__shortSlug":"decorators"}}},
    "staticQueryHashes": ["2420640694"]}