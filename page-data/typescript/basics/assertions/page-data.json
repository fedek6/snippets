{
    "componentChunkName": "component---src-pages-mdx-fields-category-mdx-fields-sub-category-mdx-fields-short-slug-js",
    "path": "/typescript/basics/assertions/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"Assertions","date":"December 19, 2021","description":"The basics of assertions"},"fields":{"subCategory":"basics"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Assertions\",\n  \"date\": \"2021-12-19\",\n  \"description\": \"The basics of assertions\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"The basics of assertions\"), mdx(LiveExample, {\n    link: \"https://jsfiddle.net/fedek6/yc2tb9um/\",\n    mdxType: \"LiveExample\"\n  }), mdx(\"p\", null, \"Using type assertions is like being smarter that TS compiler. In fact, you're telling compiler that returned value is a specific type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let taxNumber = calculateTax(100, false) as number;\\nlet taxString = calculateTax(100, true) as string;\\nconsole.log(`Number Value: ${taxNumber.toFixed(2)}`);\\nconsole.log(`String Value: ${taxString.charAt(0)}`);\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Attention!\"), \" No conversion is used when asserting a type. This is information is used only by the compiler.\"), mdx(\"p\", null, \"Asserted types can be selected from returned union:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function calculateTax(amount: number, format: boolean): string | number {\\n  const calcAmount = amount * 1.2;\\n  return format ? `${calcAmount.toFixed(2)}` : calcAmount;\\n}\\n\\n// Assert as a string\\nconst taxString = calculateTax(100.455, true) as string;\\nconsole.log(taxString.constructor.name, taxString);\\n\\n// Assert as a number\\nconst taxFloat = calculateTax(100.455, false) as number;\\nconsole.log(taxFloat.constructor.name, taxFloat);\\n\\n// Alternative assertion syntax\\nconst tax = <number>calculateTax(1214.1, false);\\nconsole.log(tax.constructor.name, tax);\\n\")), mdx(\"h2\", null, \"Forced assertions\"), mdx(\"p\", null, \"If you want to assert forcibly you can use this trick:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let taxBoolean = calculateTax(100, false) as any as boolean;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"allMdx":{"group":[{"fieldValue":"basics","edges":[{"node":{"frontmatter":{"title":"Assertions"},"fields":{"shortSlug":"assertions","subCategory":"basics"},"slug":"typescript/basics/assertions/"}},{"node":{"frontmatter":{"title":"The basics of types"},"fields":{"shortSlug":"types","subCategory":"basics"},"slug":"typescript/basics/types/"}},{"node":{"frontmatter":{"title":"Basic classes"},"fields":{"shortSlug":"classes","subCategory":"basics"},"slug":"typescript/basics/classes/"}},{"node":{"frontmatter":{"title":"Maps"},"fields":{"shortSlug":"maps","subCategory":"basics"},"slug":"typescript/basics/maps/"}}],"totalCount":4}]}},"pageContext":{"id":"884d282a-1b99-5894-b306-db56906bf38b","fields__category":"typescript","fields__subCategory":"basics","fields__shortSlug":"assertions","__params":{"fields__category":"typescript","fields__subCategory":"basics","fields__shortSlug":"assertions"}}},
    "staticQueryHashes": ["2420640694"]}