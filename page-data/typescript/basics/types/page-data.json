{
    "componentChunkName": "component---src-pages-mdx-fields-category-mdx-fields-sub-category-mdx-fields-short-slug-js",
    "path": "/typescript/basics/types/",
    "result": {"data":{"mdx":{"frontmatter":{"title":"The basics of types","date":"December 19, 2021","description":"The basics of types"},"fields":{"subCategory":"basics"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The basics of types\",\n  \"date\": \"2021-12-19\",\n  \"description\": \"The basics of types\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"The basics of types\"), mdx(\"h2\", null, \"Type annotations\"), mdx(\"p\", null, \"Basic example. Annotiate parameter and function output.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function calculateTax(amount: number): number {\\n  return amount * 1.2;\\n}\\n\")), mdx(\"h2\", null, \"Implicitly defined types\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function calculateTax(amount: number) {\\n  return amount * 1.2;\\n}\\n\")), mdx(\"p\", null, \"TypeScript will automatically determine type of the returned value.\"), mdx(\"p\", null, \"When you set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"declaration\"), \" config variable to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \", compiler will generate file with types used in your code. This might be useful for debugging.\"), mdx(\"h2\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"any\"), \" type\"), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" will stop compiler from checking the type.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" can be assigned to any other type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let newResult: any = calculateTax(200);\\nlet myNumber: number = newResult;\\nconsole.log(`Number value: ${myNumber.toFixed(2)}`);\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Notice\"), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \" is like a ugly hack in TS. If compiler cannot determine implicitly variable type, it will be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"any\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Notice\"), \": You can disable this default behavior by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noImplicityAny\"), \" option.\"), mdx(\"h2\", null, \"Simple unions\"), mdx(\"p\", null, \"Output of this function might be a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" or a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function calculateTax(amount: number, format: boolean): string | number {\\n  const calcAmount = amount * 1.2;\\n  return format ? `${calcAmount.toFixed(2)}` : calcAmount;\\n}\\n\\nlet taxNumber = calculateTax(100, false);\\nlet taxString = calculateTax(100, true);\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Notice\"), \": it depends on a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"format\"), \" parameter.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"allMdx":{"group":[{"fieldValue":"basics","edges":[{"node":{"frontmatter":{"title":"Assertions"},"fields":{"shortSlug":"assertions","subCategory":"basics"},"slug":"typescript/basics/assertions/"}},{"node":{"frontmatter":{"title":"The basics of types"},"fields":{"shortSlug":"types","subCategory":"basics"},"slug":"typescript/basics/types/"}},{"node":{"frontmatter":{"title":"Basic classes"},"fields":{"shortSlug":"classes","subCategory":"basics"},"slug":"typescript/basics/classes/"}},{"node":{"frontmatter":{"title":"Maps"},"fields":{"shortSlug":"maps","subCategory":"basics"},"slug":"typescript/basics/maps/"}}],"totalCount":4}]}},"pageContext":{"id":"682cb80f-5125-5fb4-ae53-f3f11bd92170","fields__category":"typescript","fields__subCategory":"basics","fields__shortSlug":"types","__params":{"fields__category":"typescript","fields__subCategory":"basics","fields__shortSlug":"types"}}},
    "staticQueryHashes": ["2420640694"]}